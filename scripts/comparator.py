#!/usr/bin/env python
import sys
import os
import ast
import uuid
import cv2
import random
import numpy as np
from datetime import datetime, timedelta
import pandas as pd
from scipy.spatial.distance import cosine, chebyshev

import rospy
import rospkg
from std_msgs.msg import String
from std_msgs.msg import Int32MultiArray

rp = rospkg.RosPack()
uid = uuid.uuid4().hex

test_name = "pred_3_prednet_bot_c"
outputName = test_name + uid +".csv"
CSV_PATH = os.path.join(rp.get_path("action_recognition"), "scripts", "test_results", outputName)

def resize(a, x):
    if x != 0:
        for i in range(x):
            index = random.randint(1, a.size / 2 - 2)
            a = np.insert(a, index, a[index], axis=0)
    return a


def adjust(arr, matrix):
    """
    @param arr: tracked trajectory
    @param matrix: trajectories from monitor
    @return: all trajectories of the same length
    """
    arr_len, mat_len = arr.shape[0], matrix.shape[1]
    diff = abs(arr_len - mat_len)
    if arr_len < mat_len:
        arr = resize(arr, diff)
    elif arr_len > mat_len:
        c = np.zeros((3, arr_len, 2))
        for i in range(matrix.shape[0]):
            c[i] = resize(matrix[i], arr.shape[0] - matrix.shape[1])
        matrix = c
    return arr, matrix


def norm(a):
    """
    @param a: Array to normalize
    @return: Mean normalized array
    """
    mean_x = int(np.mean(a[:, 0]))
    mean_y = int(np.mean(a[:, 1]))
    a[..., 0] -= mean_x
    a[..., 1] -= mean_y
    return a


def norm_matrix(b):
    for i in range(b.shape[0]):
        b[i] = norm(b[i])
    return b


def distance(v1, v2):
    """
    Euclidean distance redefined
    """
    return np.sqrt(np.sum((v1 - v2) ** 2))


def newTest(test_number):
    """
    @param test_number: Number of tests needed
    @return: empty form for output csv data
    """
    a = {
        "name": np.empty(test_number, dtype='<U10'),
        "start_time": np.empty(test_number, dtype='<U25'),
        "2_ed_pred": np.zeros(test_number, bool),
        "4_ed_pred": np.zeros(test_number, bool),
        "6_ed_pred": np.zeros(test_number, bool),
        "2_ed_m": np.empty(test_number, dtype='<U50'),
        "4_ed_m": np.empty(test_number, dtype='<U50'),
        "6_ed_m": np.empty(test_number, dtype='<U50'),
        "2_cheb_pred": np.zeros(test_number, bool),
        "4_cheb_pred": np.zeros(test_number, bool),
        "6_cheb_pred": np.zeros(test_number, bool),
        "2_cheb_m": np.empty(test_number, dtype='<U50'),
        "4_cheb_m": np.empty(test_number, dtype='<U50'),
        "6_cheb_m": np.empty(test_number, dtype='<U50'),
        "2_cos_pred": np.zeros(test_number, bool),
        "4_cos_pred": np.zeros(test_number, bool),
        "6_cos_pred": np.zeros(test_number, bool),
        "2_cos_m": np.empty(test_number, dtype='<U50'),
        "4_cos_m": np.empty(test_number, dtype='<U50'),
        "6_cos_m": np.empty(test_number, dtype='<U50'),
    }
    return a


class Comparator(object):
    """
    Proof the capability of MVAE to reconstruct or to predict a position of Robot's Finger,
    by finding out witch trajectory was generated by Robot between some noising trajectories
    """

    def __init__(self, mode, test_number):
        self.path = '/action_recognition/pos_reconstruction'
        if mode == '1':
            self.path = '/action_recognition/pos_prediction'
        self.sub_rec = rospy.Subscriber(self.path, String, self.receive_rec_data, queue_size=1)
        self.sub_monitor = rospy.Subscriber('/action_recognition/monitor/data',
                                            Int32MultiArray, self.receive_monitor_data,
                                            queue_size=1)
        self.status_subscriber = rospy.Subscriber("/action_recognition/test_status",
                                                  String, self.synchronize, queue_size=20)
        self.monitor_data = np.array([])
        self.reconstr_data = np.array([])
        self.mode = 0
        self.test_number = test_number
        self.status = ""
        self.name = ""

        self.test = newTest(self.test_number)
        self.rec_counter, self.monitor_counter, self.test_counter = 0, 0, 0

    def synchronize(self, msg):
        """
        Callback
        Method used to synchronize test process between ROS nodes
        @param msg: contains the info about test process
        """
        msg = msg.data.split(' ')
        self.status = msg[0]
        if self.status == "prepare":
            self.name = msg[1]
            self.test['name'][self.test_counter] = msg[1]
            print("start of ", self.name)
        if self.status == "start":
            time = msg[2] + ' ' + msg[3]
            date_time_obj = datetime.strptime(time, '%Y-%m-%d %H:%M:%S.%f')
            self.test['start_time'][self.test_counter] = date_time_obj.strftime("%H:%M:%S")
            self.timer(date_time_obj)
        if self.status == "end":
            print("end of test N", self.test_counter)
            image = np.ones([480, 640, 3], dtype=np.uint8) * 255
            if self.monitor_data.size > 4:
                cv2.polylines(image, [self.monitor_data[0]], False, (255, 0, 0), 2, lineType=4)
                cv2.polylines(image, [self.monitor_data[1]], False, (0, 255, 0), 2, lineType=4)
                cv2.polylines(image, [self.monitor_data[2]], False, (0, 0, 255), 2, lineType=4)
            if self.reconstr_data.size > 4:
                cv2.polylines(image, [self.reconstr_data], False, (0, 0, 0), 2, lineType=6)
            imName = self.name + test_name + uid + ".png"
            IM_PATH = os.path.join(rp.get_path("action_recognition"), "scripts", "test_results", "imgs", imName)
            cv2.imwrite(IM_PATH, image)
            self.test_counter += 1
            self.rec_counter = 0
            self.monitor_counter = 0

    def receive_monitor_data(self, data):
        """
        Callback
        @param data: 3d Array with N trajectories from Monitor node
        """
        # reformat data to np array
        self.last_directions = [0]
        l = data.layout.dim[1].size
        input_monitor = np.asarray(data.data)
        self.monitor_data = input_monitor.reshape(3, l, 2)
        self.monitor_counter += 1

    def receive_rec_data(self, data):
        """
        Callback
        @param data: 2D-array of points
        """
        points = ast.literal_eval(data.data)
        self.reconstr_data = np.asarray(points, dtype=int)
        self.rec_counter += 1

    def get_path_dist(self):
        if self.test_counter < self.test_number:
            print(len(self.reconstr_data), len(self.monitor_data))
            index_1, index_2, index_3, index_4 = 3, 3, 3, 3
            ed, cheb, cos = np.zeros(3), np.zeros(3), np.zeros(3)
            if not self.reconstr_data.size == 0:
                a, b = adjust(self.reconstr_data, self.monitor_data)
                Aflat = np.hstack(a)
                for i in range(b.shape[0]):
                    ed[i] = distance(a, b[i])
                    Bflat = np.hstack(b[i])
                    cheb[i] = chebyshev(Aflat, Bflat)
                    cos[i] = 1 - cosine(Aflat, Bflat)
                ed = np.round(ed, 2)
                cheb = np.round(cheb, 2)
                cos = np.round(cos, 4)
                index_1 = np.argmin(ed)
                index_3 = np.argmin(cheb)
                index_4 = np.argmax(cos)
                ed = ", ".join(str(x) for x in ed)
                cheb = ", ".join(str(x) for x in cheb)
                cos = ", ".join(str(x) for x in cos)

            return index_1 == 0, ed, index_3 == 0, cheb, index_4 == 0, cos
        return 0, 0, 0, 0, 0, 0

    def timer(self, dt):
        """
        Evaluates the tests at some time points
        @param dt: Start time of running test
        """
        x, y, z = False, False, False
        while not x or not y or not z:
            if (datetime.now() - dt) >= timedelta(seconds=2) and not x:
                self.test["2_ed_pred"][self.test_counter], self.test["2_ed_m"][self.test_counter], \
                self.test["2_cheb_pred"][self.test_counter], self.test["2_cheb_m"][self.test_counter], \
                self.test["2_cos_pred"][self.test_counter], self.test["2_cos_m"][
                    self.test_counter] = self.get_path_dist()
                x = True
            if (datetime.now() - dt) >= timedelta(seconds=4) and not y:
                self.test["4_ed_pred"][self.test_counter], self.test["4_ed_m"][self.test_counter], \
                self.test["4_cheb_pred"][self.test_counter], self.test["4_cheb_m"][self.test_counter], \
                self.test["4_cos_pred"][self.test_counter], self.test["4_cos_m"][
                    self.test_counter] = self.get_path_dist()
                y = True
            if (datetime.now() - dt) >= timedelta(seconds=6) and not z:
                self.test["6_ed_pred"][self.test_counter], self.test["6_ed_m"][self.test_counter], \
                self.test["6_cheb_pred"][self.test_counter], self.test["6_cheb_m"][self.test_counter], \
                self.test["6_cos_pred"][self.test_counter], self.test["6_cos_m"][
                    self.test_counter] = self.get_path_dist()
                z = True


def main(args):
    uid = uuid.uuid4().hex
    test_number = 3
    if len(args) > 1:
        mode = args[1]
    else:
        mode = 0
    if len(args) > 2:
        try:
            test_number = int(args[2])
        except:
            print ("Number of prediction step (arg 3) should be int")

    # The node should start the last after all others nodes
    rospy.sleep(40)
    ic = Comparator(mode, test_number)
    rospy.init_node('comparator', anonymous=True)

    try:
        while ic.test_counter < test_number:
            pass

        df = pd.DataFrame(data=ic.test,
                          columns=['name', 'start_time', "2_ed_pred", "2_ed_m", "4_ed_pred", "4_ed_m", "6_ed_pred",
                                   "6_ed_m", "2_cheb_pred", "2_cheb_m", "4_cheb_pred", "4_cheb_m", "6_cheb_pred",
                                   "6_cheb_m", "2_cos_pred", "2_cos_m", "4_cos_pred", "4_cos_m", "6_cos_pred",
                                   "6_cos_m"])
        df.to_csv(CSV_PATH, sep=',')
    except KeyboardInterrupt:
        print ("Shutting down ROS comparator module")


if __name__ == '__main__':
    main(sys.argv)
