#!/usr/bin/env python
import sys
import ast
import random
import numpy as np
from scipy import spatial
from datetime import datetime, timedelta

from scipy.spatial.distance import directed_hausdorff

import rospy
from std_msgs.msg import String
from std_msgs.msg import Int32MultiArray

def resize(a, x):
    if x != 0:
        for i in range(x):
            index = random.randint(1, a.size/2 - 2)
            a = np.insert(a, index, a[index], axis=0)
    return a


def adjust(a, b):
    print("before", a.shape, b.shape)
    if a.shape[0] < b.shape[1]:
        a = resize(a, b.shape[1] - a.shape[0])
        return norm(a), norm_matrix(b)
    else:
        c = np.zeros(3, a.shape[0], a.shape[1])
        for i in range (b.shape[0]):
            c[i] = resize(b[i], a.shape[1]-b.shape[0])
        return norm(a), norm(c)

def norm(a):
    mean_x = int(np.mean(a[:,0]))
    mean_y = int(np.mean(a[:,1]))
    a[...,0] -= mean_x
    a[...,1] -= mean_y
    return a

def norm_matrix(b):
    for i in range(b.shape[0]):
        b[i]=norm(b[i])
    return b

def distance(v1, v2):
    return np.sqrt(np.sum((v1 - v2) ** 2))

class Comparator(object):
    """
    Proof the capability of MVAE to reconstruct or to predict a position of Robot's Finger,
    by finding out witch trajectory was generated by Robot between some noising trajectories
    """

    def __init__(self):
        self.sub_rec = rospy.Subscriber('/action_recognition/pos_reconstruction',
                                        String, self.receive_rec_data,
                                        queue_size=1)
        self.sub_pred = rospy.Subscriber('/action_recognition/pos_prediction',
                                         Int32MultiArray, self.receive_data, queue_size=1)
        self.sub_monitor = rospy.Subscriber('/action_recognition/monitor/data',
                                            Int32MultiArray, self.receive_monitor_data,
                                            queue_size=1)
        #self.pub = rospy.Publisher('/action_recognition/results', String, queue_size=10)
        self.status_subscriber = rospy.Subscriber("/action_recognition/test_status",
                                                  String, self.synchronize, queue_size=20)
        self.monitor_data = np.array([])
        self.reconstr_data = np.array([])
        self.mode = 0
        self.status = ""
        self.tests = []
        self.test = {
            "name": " ", "start_time": " ",
            "accuracy_1": " ","accuracy_2": " ", "accuracy_3": " ",
            "ed_1": " ", "ed_2": " ", "ed_3": " ",
        }
        self.rec_counter, self.monitor_counter, self.test_counter= 0, 0, 0
        #results = [0,0,0]

    def synchronize(self, msg):
        """
        Callback
        Method used to synchronize test process between ROS nodes
        @param msg: contains the info about test process
        """
        msg = msg.data.split(' ')
        self.status = msg[0]
        if self.status == "prepare":
            self.test['name'] = msg[1]
        if self.status == "start":
            time = msg[2] + ' ' + msg[3]
            date_time_obj = datetime.strptime(time, '%Y-%m-%d %H:%M:%S.%f')
            self.test['start_time'] = date_time_obj.strftime("%H:%M:%S")
            self.timer(date_time_obj)
        if self.status == "end":
            self.tests.append(self.test)
            self.test_counter += 1
            self.test = {}
            self.rec_counter = 0
            self.monitor_counter = 0

    def receive_monitor_data(self, data):
        """
        Callback
        @param data: 3d Array with N trajectories from Monitor node
        """
        # reformat data to np array
        self.last_directions = [0]
        l = data.layout.dim[1].size
        input_monitor = np.asarray(data.data)
        self.monitor_data = input_monitor.reshape(3, l, 2)
        self.monitor_counter += 1

    def receive_rec_data(self, data):
        """
        Callback
        @param data: 2D-array of points
        """
        points = ast.literal_eval(data.data)
        self.reconstr_data = np.asarray(points, dtype=int)
        self.rec_counter += 1

    def receive_data(self, data):
        """
        Callback
        @param data: 2D-array of points
        """
        pass
        #l = data.layout.dim[0].size
        #input_reconstructor = np.asarray(data.data)
        #self.reconstr_data = input_reconstructor.reshape(l, 2)
        #self.rec_counter += 1


    def find_min_ed(self):
        index = 3
        results, hausdorffs, cdist = np.zeros(3), np.zeros(3), np.zeros(3)
        if not self.reconstr_data.size == 0:
            a, b = adjust(self.reconstr_data, self.monitor_data)
            for i in range(b.shape[0]):
                results[i] = distance(a, b[i])
                cdist[i] = np.trace(spatial.distance.cdist(a, b[i]))
                hausdorffs[i] = directed_hausdorff(a, b[i])[0]
                print "results:", cdist
                print "mean:", np.min(cdist)
            index_1 = np.argmin(results)
            index_2 = np.argmin(hausdorffs)
            index_3 = np.argmin(cdist)
        return index_1 == 0, results, index_2 == 0, hausdorffs, index_3==0, cdist


    def timer(self, dt):
        """
        Evaluates the tests at some time points
        @param dt: Start time of running test
        """
        x, y, z = False, False, False
        while not x or not y or not z:
            if (datetime.now() - dt) >= timedelta(seconds=2) and not x:
                self.test['acc_1'], self.test['ed_1'], self.test['acc_1'], self.test['h_1'], self.test['accC_1'], self.test['c_1']  = self.find_min_ed()
                #print(self.find_hausdorff())
                x = True
            if (datetime.now() - dt) >= timedelta(seconds=3) and not y:
                self.test['acc_2'], self.test['ed_2'], self.test['acc_2'], self.test['h_2'], self.test['accC_2'], self.test['c_2']  = self.find_min_ed()
                y = True
            if (datetime.now() - dt) >= timedelta(seconds=5) and not z:
                self.test['acc_3'], self.test['ed_3'], self.test['accH_3'], self.test['h_3'], self.test['accC_3'], self.test['c_3'] = self.find_min_ed()
                z = True
                #print ("Rec", self.reconstr_data)
                #print ("Real", self.monitor_data[0])



def main(args):
    ic = Comparator()
    rospy.init_node('comparator', anonymous=True)
    rospy.sleep(10)
    if args != "":
        Comparator.mode = args
    try:
        while ic.test_counter < 3:
            rospy.spin()
        print ("Test", ic.tests)
    except KeyboardInterrupt:
        print ("Shutting down ROS comparator module")


if __name__ == '__main__':
    main(sys.argv)
