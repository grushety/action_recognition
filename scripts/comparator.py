#!/usr/bin/env python
import sys
import ast
import numpy as np
from scipy import spatial
from datetime import datetime, timedelta

from scipy.spatial.distance import directed_hausdorff

import rospy
from std_msgs.msg import String
from std_msgs.msg import Int32MultiArray


class Comparator(object):
    """
    Proof the capability of MVAE to reconstruct or to predict a position of Robot's Finger,
    by finding out witch trajectory was generated by Robot between some noising trajectories
    """

    def __init__(self):
        self.sub_rec = rospy.Subscriber('/action_recognition/pos_reconstruction',
                                        String, self.receive_rec_data,
                                        queue_size=1)
        self.sub_pred = rospy.Subscriber('/action_recognition/pos_prediction',
                                         Int32MultiArray, self.receive_data, queue_size=1)
        self.sub_monitor = rospy.Subscriber('/action_recognition/monitor/data',
                                            Int32MultiArray, self.receive_monitor_data,
                                            queue_size=1)
        #self.pub = rospy.Publisher('/action_recognition/results', String, queue_size=10)
        self.status_subscriber = rospy.Subscriber("/action_recognition/test_status",
                                                  String, self.synchronize, queue_size=20)
        self.monitor_data = []
        self.reconstr_data = np.array([])
        self.mode = 0
        self.status = ""
        self.tests = []
        self.test = {
            "name": " ", "start_time": " ",
            "accuracy_1": " ","accuracy_2": " ", "accuracy_3": " ",
            "ed_1": " ", "ed_2": " ", "ed_3": " ",
        }
        self.rec_counter, self.monitor_counter, self.test_counter= 0, 0, 0
        #results = [0,0,0]

    def synchronize(self, msg):
        """
        Callback
        Method used to synchronize test process between ROS nodes
        @param msg: contains the info about test process
        """
        msg = msg.data.split(' ')
        self.status = msg[0]
        if self.status == "prepare":
            self.test['name'] = msg[1]
        if self.status == "start":
            time = msg[2] + ' ' + msg[3]
            date_time_obj = datetime.strptime(time, '%Y-%m-%d %H:%M:%S.%f')
            self.test['start_time'] = date_time_obj.strftime("%H:%M:%S")
            self.timer(date_time_obj)
        if self.status == "end":
            print ("Monitor counter: ", self.monitor_counter)
            print ("Reconstr counter: ", self.rec_counter)
            #self.results.append(self.test)
            self.tests.append(self.test)
            self.test_counter += 1
            self.test = {}
            self.rec_counter = 0
            self.monitor_counter = 0

    def receive_monitor_data(self, data):
        """
        Callback
        @param data: 3d Array with N trajectories from Monitor node
        """
        # reformat data to np array
        self.last_directions = [0]
        l = data.layout.dim[1].size
        input_monitor = np.asarray(data.data)
        self.monitor_data = input_monitor.reshape(3, l, 2)
        self.monitor_counter += 1

    def receive_rec_data(self, data):
        """
        Callback
        @param data: 2D-array of points
        """
        points = ast.literal_eval(data.data)
        self.reconstr_data = np.asarray(points, dtype=int)
        self.rec_counter += 1

    def receive_data(self, data):
        """
        Callback
        @param data: 2D-array of points
        """
        pass
        #l = data.layout.dim[0].size
        #input_reconstructor = np.asarray(data.data)
        #self.reconstr_data = input_reconstructor.reshape(l, 2)
        #self.rec_counter += 1


    def find_min_ed(self):
        index = 3
        results = np.array([])
        if not self.reconstr_data.size == 0:
            tree = spatial.cKDTree(self.reconstr_data)
            for data in self.monitor_data:
                mindist, minid = tree.query(data)
                sum = np.mean(mindist)
                results = np.concatenate((results, [sum]))
            index = np.argmin(results)
        return index == 0, results

    def find_hausdorff(self):
        index = 3
        results = np.array([])
        if not self.reconstr_data.size == 0:
            for data in self.monitor_data:
                hausdorff = directed_hausdorff(self.reconstr_data, data)
                results = np.concatenate((results, [hausdorff]))
            index = np.argmin(results)
        return index == 0, results

    def timer(self, dt):
        """
        Evaluates the tests at some time points
        @param dt: Start time of running test
        """
        x, y, z = False, False, False
        while not x or not y or not z:
            if (datetime.now() - dt) >= timedelta(seconds=2) and not x:
                self.test['accuracy_1'], self.test['ed_1'] = self.find_min_ed()
                print(self.find_hausdorff())
                x = True
            if (datetime.now() - dt) >= timedelta(seconds=3) and not y:
                self.test['accuracy_2'], self.test['ed_2'] = self.find_min_ed()
                y = True
            if (datetime.now() - dt) >= timedelta(seconds=5) and not z:
                self.test['accuracy_3'], self.test['ed_3'] = self.find_min_ed()
                z = True
                #print ("Rec", self.reconstr_data)
                #print ("Real", self.monitor_data[0])


def main(args):
    ic = Comparator()
    rospy.init_node('comparator', anonymous=True)
    rospy.sleep(10)
    if args != "":
        Comparator.mode = args
    try:
        while ic.test_counter < 3:
            rospy.spin()
        print ("Test", ic.tests)
    except KeyboardInterrupt:
        print ("Shutting down ROS comparator module")


if __name__ == '__main__':
    main(sys.argv)
